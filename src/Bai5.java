import java.awt.*;
import java.util.*;
import java.util.List;
import javax.swing.*;

class Maze {
    public static void main(String[] args) {
        //
        JFrame frame = new JFrame();
        frame.setSize(650, 470);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        MazePanel mp = new MazePanel();
        frame.add(mp);
        frame.setVisible(true);
    }

    public static class MazePanel extends JPanel {
        private static final long serialVersionUID = -566807999447681130L;
        private int[][] maze = { // khởi tạo ma trận mảng 2 chiều
                { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
                { 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 },
                { 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },
                { 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 },
                { 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1 },
                { 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1 },
                { 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1 },
                { 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1 },
                { 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1 },
                { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1 },
                { 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1 },
                { 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 },
                { 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },
                { 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 },
                { 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1 },
                { 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1 },
                { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
                { 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1 },
                { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
                { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
        private int sizeh, sizew, start, end;

        public MazePanel() {
            // Kích thước ma trận
            sizeh = 21;
            sizew = 31;
            start = 10; // y
            end = 0; // x
            solve();
            repaint(); // vẽ ma trận và lời giải
        }

        /**
         * Implement một phương pháp tìm đường nào đó.
         * <p>
         * Yêu cầu : Vẽ đường đi từ điểm bắt đầu đến điểm kết thúc. Không hiện
         * các phần thừa - là các phần đường cụt hoặc đường đi bị sai. Chỉ vẽ
         * tuyến đường chính đi từ điểm đầu (màu vàng) đến màu đỏ.
         * <p>
         * Đường đi từ điểm đầu đến điểm cuối được tô màu xanh dương, để tô màu
         * xanh dương hãy set giá trị của điểm trên ma trận sang một số > 2
         */
        public void solve() {
            // Hàm này chứa phương pháp tìm đường từ điểm start đến vị
            // trí màu đỏ trên ma trận
            Stack<Point> stack = new Stack<>();
            Set<Point> visistedPoints = new HashSet<>();
            Point start = new Point(this.end, this.start);
            start.setPreviousPoint(null);
            stack.add(start);
            visistedPoints.add(start);
            while (! stack.empty()) {
                Point point = stack.pop();
                System.out.println(point.x + "   " + point.y);
                visistedPoints.add(point);
                if (maze[point.y][point.x] == 2) {
                    for (Point previousPoint = point.previousPoint; previousPoint != null; previousPoint = previousPoint.getPreviousPoint()) {
                        maze[previousPoint.y][previousPoint.x] = 3;
                    }
                    break;
                }
                for (Point temp : point.getAdjacentPoint()) {
                    if (!visistedPoints.contains(temp)) {
                        temp.setPreviousPoint(point);
                        stack.push(temp);
                    }
                }
            }
        }

        public void paintComponent(Graphics g) // vẽ ma trận + lời giải
        {
            super.paintComponent(g);
            for (int j = 0; j < sizew; j++)
                for (int i = 0; i < sizeh; i++) {
                    if (i == start && j == end)
                        g.setColor(Color.yellow);
                    else if (maze[i][j] == 0)
                        g.setColor(Color.white);
                    else if (maze[i][j] == 1)
                        g.setColor(Color.black);
                    else if (maze[i][j] == 2)
                        g.setColor(Color.red);
                    else
                        g.setColor(Color.blue); // blue là màu của lời giải
                    g.fillRect(j * 20, i * 20, 20, 20);
                }
        }

        public class Point {
            private int x;
            private int y;
            private Point previousPoint;
            public Point(int x, int y) {
                this.y = y;
                this.x = x;
            }

            public ArrayList<Point> getAdjacentPoint() {
                ArrayList<Point> list = new ArrayList<>();
                if (this.y > 0 && (maze[this.y-1][this.x] == 0 || maze[this.y-1][this.x] == 2)) list.add(new Point(this.x, this.y-1));
                if (this.y < 19 && (maze[this.y+1][this.x] == 0 || maze[this.y+1][this.x] == 2)) list.add((new Point(this.x, this.y+1)));
                if (this.x > 0 && (maze[this.y][this.x-1] == 0 || maze[this.y][this.x-1] == 2)) list.add(new Point(this.x-1, this.y));
                if (this.x < 29 && (maze[this.y][this.x+1] == 0 || maze[this.y][this.x+1] == 2)) list.add(new Point(this.x+1, this.y));
                return list;
            }

            public void setPreviousPoint(Point previousPoint) {
                this.previousPoint = previousPoint;
            }

            public Point getPreviousPoint() {
                return previousPoint;
            }

            @Override
            public boolean equals(Object obj) {
                if (obj == null) return false;
                if (obj.getClass() != this.getClass()) return false;
                Point anotherPoint = (Point) obj;
                return this.x == anotherPoint.x && this.y == anotherPoint.y;
            }

            @Override
            public int hashCode() {
                return Objects.hash(this.x, this.y);
            }
        }
    }
}
